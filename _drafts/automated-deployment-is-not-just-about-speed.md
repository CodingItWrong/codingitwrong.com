---
title: Automated Testing is Not Just About Speed
---

Before I had my first kid, a friend told me that until you have children your whole life is a vacation. I figured she was exaggerating: sure, kids are an extra responsibility, but people with kids still go to movies and play video games, right? Then my wife and I had the baby, and wow—I really *was* on vacation before that. It's not just a matter of having slightly less time: it's a whole different way of thinking. We don't make a single decision without thinking about the baby; she's never off our minds. It's a paradigm shift, and I'm not sure there's any way to fully understand it before you cross the threshold.

I was reminded of this paradigm shift when I looked back on [NPM Digital](http://npmdigital.org)'s move from manual software deployment to automated deployment while I worked for them. That was a paradigm shift, too, but in the opposite direction: no matter how easy you think your manual deployment process, automated deployment is a vacation by comparison. But it's not just a matter of having slightly faster deployments; it totally changes the way you think about the development process. You’re able to do things that were never possible before.

If you're still doing deployments manually, here's my experience of what it's like on the other side of the paradigm shift, and encourage you to try it out. I won't be getting into different tools, because most of these benefits apply whatever tool you use.

Here are some of the things that can totally change in your development process when deployment is automated:

1. **Front-loaded risk.** When we did deployments manually, our initial production deployment of new systems was at the very end, once they were fully complete. It was risky—what if a server environment wasn't set up right? But because deployments took an hour or more, we wanted to save them until the project was complete. Now that deployments are automatic, we can do our initial server setup as soon as the project starts, because subsequent deployments are as easy as the click of a button. This allows us to fix any server issues while there's still plenty of time to do it.

2. **Fewer mistakes.** This one is pretty obvious. When your manual deployment process has a list of 20 steps, and only half apply to a given system, you're going to make mistakes no matter how diligent you are. When the deployment steps are scripted, your tool doesn't make these mistakes. This means less time tracking down errors in the code only to find that they’re environmental.

3. **Fewer bottlenecks.** When our deployments were manual, at any given time our team had one person responsible for all deployments. Anything more than a quick patch had to go through the deployment person, because of how complex the list of deployment steps were. And this meant the deployment person got to do very little of the development they were hired for. But now that deployments are automatic, any developer can deploy, because those complex steps are scripted. Exceptions and errors still come up, so the deployment person still has to be consulted. But since that's the exception, not the rule, we suffer far fewer bottlenecks.

4. **Shorter feedback cycles.** When deployments were manual, our tendency was to only deploy to the test server once a bundle of work was fully complete, because of how much overhead they had. But now that deployments are automatic, we can offer our clients the ability to see our progress weekly at review meetings. This leads to learning sooner if we need to change directions.

5. **Better deployment communication.** When we did deployments manually, we tried to remember to update a spreadsheet tracking what was deployed and when. But because this was tedious, only the deployment person ever did it (and it still sometimes got missed). For hotfixes to production (arguably the place where change history is the most important), we had no record other than file system change dates. And not every automated deployment tool is necessarily any better. But with the tool we're using, dploy.io, we get a simple web interface that shows exactly what lines of code changed on a server, when, and by whom. This information is accessible even to non-developers on the team. And since our tool integrates with our office chat, our team gets proactively notified when deployments happen.

6. **Lower stress around requirements changes.** When we did deployments manually, a late feature-change request or bug report meant redeployment to the test and production servers, which was time we didn't always have. But now that deployments are automatic, that overhead is gone and late changes are less stressful. It's not an excuse to get sloppy about process: major changes late in the game can still result in wasted work and schedule slips. But now at the last minute we have the option of doing medium changes, not just trivial ones.

So these are all great reasons to consider moving to automated deployment. However, it's not a solution to every problem. Automatic deployment doesn't take the place of team communication about changes. Nor does it remove the need for testing and code review. And no matter how well you script your deployments, things will still go wrong, so you still need to understand what's going on under the hood. But if you keep all those things in mind, automated deployment is a game-changing opportunity that you owe it to yourself to at least investigate.

So how about you—is your team doing automatic or manual deployment? If manual, what has kept you from moving toward automatic deployment? If automatic, what have been some of the ways it's changed the way your project process works?
